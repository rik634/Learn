# Rod Cutting Problem
- We are given a rod of size ‘N’. It can be cut into pieces. Each length of a piece has a particular price given by the price array. Our task is to find the maximum revenue that can be generated by selling the rod after cutting( if required) into pieces.

### Logic
- This problem can be solved by using ht 0-1 knapsack logic.
- Consider an array of length, with values from 1 to length N in order. We already have the value array.
- f(N-1, L): Till index N-1, what is the max value we can get, given that length of the rod is L.
- This problem is similar to having infinite supply, as we can have more than one rods of same length.

### Recursion
```
int f(ind,L)
{
    if(ind==0) // length of rod is 1
    {
        return L* val[0];
    }
    int notTake = f(ind-1,L);
    int take = INT_MIN;
    if((ind+1)<=L)
    {
        take = val[ind]+f(ind,L-(ind+1));
    }
    return max(notTake, take);
}
```
- Time Complexity: O(2^N)
- Space Complexity: >>O(N), in worst case, it can be = O(L)

### Memoization
```
vector<vector<int>> dp(N,vector<int>(L+1,INT_MIN));
int f(ind,L)
{
    if(ind==0) // length of rod is 1
    {
        return dp[ind][L]=L* val[0];
    }
    if(dp[ind][L]!=INT_MIN)
    {
        return dp[ind][L];
    }
    int notTake = f(ind-1,L);
    int take = INT_MIN;
    if((ind+1)<=L)
    {
        take = val[ind]+f(ind,L-(ind+1));
    }
    return dp[ind][L]=max(notTake, take);
}
```
- Time Complexity: O(N*L)
- Space Complexity: O(L) + O(N*L)

### Tabulation
```
vector<vector<int>> dp(N,vector<int>(L+1,INT_MIN));
int f()
{
    for(int i=0;i<=L;i++)
    {
        dp[0][i]=i*val[0];
    }
    for(int i=1;i<N;i++)
    {
        for(int j=0;j<=L;j++)
        {
            int notTake = dp[i-1][L];
            int take = INT_MIN;
            if((i+1)<=j)
            {
                take = val[ind]+dp[i][j-(i+1)];
           }
           dp[i][j]=max(notTake, take);
        }
    }
    return dp[N-1][L];
}
```
- Time Complexity: O(L) + O(N*L)
- Space Complexity: O(N*L)

### Space optimized
```
int f()
{
    vector<int> prev(L+1,0);
    for(int i=0;i<=L;i++)
    {
        prev[i]=i*val[0];
    }
    for(int i=1;i<N;i++)
    {
        vector<int> temp(L+1,0);   
        for(int j=0;j<=L;j++)
        {
            int notTake = prev[L];
            int take = INT_MIN;
            if((i+1)<=j)
            {
                take = val[ind]+temp[j-(i+1)];
           }
           temp [j]=max(notTake, take);
        }
        prev=temp;
    }
    return prev[L];
}
```
- Time Complexity: O(L) + O(N*L)
- Space Complexity: O(2*L)


### More Space optimized
```
int f()
{
    vector<int> prev(L+1,0);
    for(int i=0;i<=L;i++)
    {
        prev[i]=i*val[0];
    }
    for(int i=1;i<N;i++)
    {
        for(int j=L;j>=0;j--)
        {
            int notTake = prev[L];
            int take = INT_MIN;
            if((i+1)<=j)
            {
                take = val[ind]+prev[j-(i+1)];
           }
           prev[j]=max(notTake, take);
        }
        
    }
    return prev[L];
}
```
- Time Complexity: O(L) + O(N*L)
- Space Complexity: O(L)




